一、网络
1. socket简介
	socket(简称 套接字) 是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：
		它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于 Socket 来完成通信的
		例如我们每天浏览网页、QQ 聊天、收发 email 等等
2. 创建socket
	在 Python 中 使用socket 模块的函数 socket 就可以完成：

		import socket
		socket.socket(AddressFamily, Type)
		说明：
			函数 socket.socket 创建一个 socket，该函数带有两个参数：

	Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET
	Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）
	
	1)创建一个tcp socket（tcp套接字）
		import socket
		# 创建tcp的套接字
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		# ...这里是使用套接字的功能（省略）...
		# 不用的时候，关闭套接字
		s.close()
	
	2)创建一个udp socket（udp套接字）
		import socket
		# 创建udp的套接字
		s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
		# ...这里是使用套接字的功能（省略）...
		# 不用的时候，关闭套接字
		s.close()
	备注：
		1)套接字使用流程 与 文件的使用流程很类似
		2)创建套接字
		3)使用套接字收/发数据
		4)关闭套接字

2.1 udp网络程序-发送、接收数据
2.1.1. udp网络程序-发送数据
	创建一个基于udp的网络程序流程很简单，具体步骤如下：
		1)创建客户端套接字
		2)发送/接收数据
		3)关闭套接字
	代码如下：
	#coding=utf-8
	from socket import *

	# 1. 创建udp套接字
	udp_socket = socket(AF_INET, SOCK_DGRAM)

	# 2. 准备接收方的地址
	# '192.168.1.103'表示目的ip地址
	# 8080表示目的端口
	dest_addr = ('192.168.1.103', 8080)  # 注意 是元组，ip是字符串，端口是数字

	# 3. 从键盘获取数据
	send_data = input("请输入要发送的数据:")

	# 4. 发送数据到指定的电脑上的指定程序中
	udp_socket.sendto(send_data.encode('utf-8'), dest_addr)

	# 5. 关闭套接字
	udp_socket.close()

2.1.2 udp网络程序-发送、接收数据
	#coding=utf-8

	from socket import *

	# 1. 创建udp套接字
	udp_socket = socket(AF_INET, SOCK_DGRAM)

	# 2. 准备接收方的地址
	dest_addr = ('192.168.236.129', 8080)

	# 3. 从键盘获取数据
	send_data = input("请输入要发送的数据:")

	# 4. 发送数据到指定的电脑上
	udp_socket.sendto(send_data.encode('utf-8'), dest_addr)

	# 5. 等待接收对方发送的数据
	recv_data = udp_socket.recvfrom(1024)  # 1024表示本次接收的最大字节数

	# 6. 显示对方发送的数据
	# 接收到的数据recv_data是一个元组
	# 第1个元素是对方发送的数据
	# 第2个元素是对方的ip和端口
	print(recv_data[0].decode('gbk'))
	print(recv_data[1])

	# 7. 关闭套接字
	udp_socket.close()

2.2 python3中的编码与解码
	1)str->bytes:encode编码
	2)bytes->str:decode解码
	字符串通过编码成为字节码，字节码通过解码成为字符串。
	其中decode()与encode()方法可以接受参数，其声明分别为:
		bytes.decode(encoding="utf-8", errors="strict")
		str.encode(encoding="utf-8", errors="strict")
		其中的encoding是指在解码编码过程中使用的编码(此处指“编码方案”是名词)，errors是指错误的处理方案。
	
2.3 udp中绑定端口的问题
	1) 绑定信息
		一般情况下，在一台电脑上运行的网络程序有很多，为了不与其他的网络程序占用同一个端口号，往往在编程中，udp的端口号一般不绑定
		但是如果需要做成一个服务器端的程序的话，是需要绑定的，想想看这又是为什么呢？
		如果报警电话每天都在变，想必世界就会乱了，所以一般服务性的程序，往往需要一个固定的端口号，这就是所谓的端口绑定
	2)绑定示例
		#coding=utf-8
		from socket import *

		# 1. 创建套接字
		udp_socket = socket(AF_INET, SOCK_DGRAM)

		# 2. 绑定本地的相关信息，如果一个网络程序不绑定，则系统会随机分配
		local_addr = ('', 7788) #  ip地址和端口号，ip一般不用写，表示本机的任何一个ip
		udp_socket.bind(local_addr)

		# 3. 等待接收对方发送的数据
		recv_data = udp_socket.recvfrom(1024) #  1024表示本次接收的最大字节数

		# 4. 显示接收到的数据
		print(recv_data[0].decode('gbk'))

		# 5. 关闭套接字
		udp_socket.close()
2.4 应用udp聊天室
	import socket
	def send_msg(udp_socket):
		"""获取键盘数据，并将其发送给对方"""
		# 1. 从键盘输入数据
		msg = input("\n请输入要发送的数据:")
		# 2. 输入对方的ip地址
		dest_ip = input("\n请输入对方的ip地址:")
		# 3. 输入对方的port
		dest_port = int(input("\n请输入对方的port:"))
		# 4. 发送数据
		udp_socket.sendto(msg.encode("utf-8"), (dest_ip, dest_port))
	def recv_msg(udp_socket):
		"""接收数据并显示"""
		# 1. 接收数据
		recv_msg = udp_socket.recvfrom(1024)
		# 2. 解码
		recv_ip = recv_msg[1]
		recv_msg = recv_msg[0].decode("utf-8")
		# 3. 显示接收到的数据
		print(">>>%s:%s" % (str(recv_ip), recv_msg))
	def main():
		# 1. 创建套接字
		udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
		# 2. 绑定本地信息
		udp_socket.bind(("", 7890))
		while True:
			# 3. 选择功能
			print("="*30)
			print("1:发送消息")
			print("2:接收消息")
			print("="*30)
			op_num = input("请输入要操作的功能序号:")

			# 4. 根据选择调用相应的函数
			if op_num == "1":
				send_msg(udp_socket)
			elif op_num == "2":
				recv_msg(udp_socket)
			else:
				print("输入有误，请重新输入...")

	if __name__ == "__main__":
		main()
		
		
3  网络tcp
3.1 tcp简介
	TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。
	TCP通信需要经过创建连接、数据传送、终止连接三个步骤。
	TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，"打电话""
tcp特点：
	1)面向连接
		通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。
		双方间的数据传输都可以通过这一个连接进行。
		完成数据交换后，双方必须断开此连接，以释放系统资源。
		这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。
	2)可靠传输
		1)TCP采用发送应答机制
		  TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功
		2)超时重传
		   发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。
		   TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。
		3错误校验
		    TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。
		4)流量控制和阻塞管理
		   流量控制用来避免主机发送得过快而使接收方来不及完全收下。
	
	TCP与UDP的不同点:
		1)面向连接（确认有创建三方交握，连接已创建才作传输。）
		2)有序数据传输
		3)重发丢失的数据包
		4)舍弃重复的数据包
		5)无差错的数据传输
		6)阻塞/流量控制
		
3.2 tcp客户端
	tcp的客户端要比服务器端简单很多，如果说服务器端是需要自己买手机、查手机卡、设置铃声、等待别人打电话流程的话，
	那么客户端就只需要找一个电话亭，拿起电话拨打即可，流程要少很多
	示例代码：
	from socket import *

	# 创建socket
	tcp_client_socket = socket(AF_INET, SOCK_STREAM)

	# 目的信息
	server_ip = input("请输入服务器ip:")
	server_port = int(input("请输入服务器port:"))

	# 链接服务器
	tcp_client_socket.connect((server_ip, server_port))

	# 提示用户输入数据
	send_data = input("请输入要发送的数据：")

	tcp_client_socket.send(send_data.encode("gbk"))

	# 接收对方发送过来的数据，最大接收1024个字节
	recvData = tcp_client_socket.recv(1024)
	print('接收到的数据为:', recvData.decode('gbk'))

	# 关闭套接字
	tcp_client_socket.close()
	
	
3.3 tcp服务器端
   如同上面的电话机过程一样，在程序中，如果想要完成一个tcp服务器的功能，需要的流程如下：
		1)socket创建一个套接字
		2)bind绑定ip和port
		3)listen使套接字变为可以被动链接
		4)accept等待客户端的链接
		5)recv/send接收发送数据
    一个很简单的tcp服务器如下：
	from socket import *
	# 创建socket
	tcp_server_socket = socket(AF_INET, SOCK_STREAM)
	# 本地信息
	address = ('', 7788)
	# 绑定
	tcp_server_socket.bind(address)
	# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了
	tcp_server_socket.listen(128)
	# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务
	# client_socket用来为这个客户端服务
	# tcp_server_socket就可以省下来专门等待其他新客户端的链接
	client_socket, clientAddr = tcp_server_socket.accept()
	# 接收对方发送过来的数据
	recv_data = client_socket.recv(1024)  # 接收1024个字节
	print('接收到的数据为:', recv_data.decode('gbk'))
	# 发送一些数据到客户端
	client_socket.send("thank you !".encode('gbk'))
	# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接
	client_socket.close()
	
	//注意 ：
		1)recv函数与recvfrom()的区别是 recvfrom()带有返回的IP地址等信息
		2)recv()函数只是返回的客户端发来的数据
		3)可以通过recv()函数返回数据是否为空,判断客户端是否断开连接
	
3.4 tcp服务器端循环发送消息
	import socket
	def main():
		# 创建socket对象
		tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		# 绑定信息
		localtion_address = ("",7788)
		tcp_socket.bind(localtion_address)
		# 监听 使用socket创建的套接字是主动的  使用listen让其变为被动
		tcp_socket.listen(128)
		# 等待客户端连接
		while True:
			print("等待新的客户端连接")
			new_socket, address = tcp_socket.accept()
			print("连接的客户端信息为："+str(address))
			while True:
				recv_data = new_socket.recv(1024)
				if recv_data:
					print("客户端发来的信息为："+recv_data.decode("gbk"))
					new_socket.send("您好，这里是服务端，收到你的信息".encode("gbk"))
				else:
					break
			new_socket.close()
		tcp_socket.close()
	if __name__ == "__main__":
		main()